import drjit as dr
import numpy as np
import mitsuba as mi 
from mitsuba import Float, UInt32, Point1f, TensorXf
from PDE2D import DIM, PATH
import os
from .green import GreensFunction

class GreensFunctionPolynomial(GreensFunction):
    def __init__(self, dim : DIM, newton_steps: int = 4, grad : bool = False, ncoeffs : int = 8) -> None:
        """
        Load a binary file containing series expansion coefficients describing
        the Green's function in 2D or 3D.

        The parameter ``newton_it`` specifies how many Newton iteration steps
        the implementation should perform in the ``.sample()`` method following
        initialization from a starting guess.
        """

        import array
        import struct

        super().__init__(dim, grad, newton_steps)

        if self.is_grad:
            filename = f"green_grad_3d_{ncoeffs}.model" if dim == DIM.Three else f"green_grad_2d_{ncoeffs}.model"
        else:
            filename = f"green_3d_{ncoeffs}.model" if dim == DIM.Three else f"green_2d_{ncoeffs}.model"

        filename = os.path.join(PATH,"PDE2D", "GreenModels", filename)

        with open(filename, "rb") as f:
            # Double-check that this file was generated by the Mathematica notebook
            if f.read(5) != b"GREEN":
                raise RuntimeError(
                    f'GreensFunction("{filename}"): incompatible input file.'
                )

            # Following the header, the file stores a few integers. The first
            # one specifies whether the coefficients represent a Green's
            # function or its gradient.
            is_grad: int = struct.unpack("i", f.read(4))[0]
            if is_grad != 0 and is_grad != 1:
                raise RuntimeError(f'GreensFunction("{filename}"): invalid input.')
            self.is_grad: bool = is_grad == 1

            # The next field specifies the number of dimensions, which must be
            # known by some functions below
            self.ndim: int = struct.unpack("i", f.read(4))[0]
            if self.ndim != 2 and self.ndim != 3:
                raise RuntimeError(
                    f'GreensFunction("{filename}"): expected a 2D or 3D model file.'
                )

            # Number of coefficients per 'z' value
            self.ncoeffs: int = struct.unpack("i", f.read(4))[0]

            # Number of sampled 'z' values contained in the file
            self.nsamples: int = struct.unpack("i", f.read(4))[0]

            # Largest 'z' value represented in the file
            self.zmax: float = struct.unpack("f", f.read(4))[0]

            data = f.read()
            if len(data) != self.ncoeffs * self.nsamples * 4:
                raise RuntimeError(f'GreensFunction("{filename}"): invalid file size.')

        coeff_flat = np.array(array.array("f", data)).squeeze()
        data_shape = (self.nsamples, self.ncoeffs)
        #coeff_tensor = TensorXf(coeff_flat, shape = data_shape)
        coeff_tensor = TensorXf(coeff_flat, shape=data_shape)

        # Create a 1D texture to interpolate the loaded data
        self.coeff_tex = mi.Texture1f(coeff_tensor)

    def initialize(self, z : Float):
        self.coeffs = self.fetch_coeffs(z)

    def fetch_coeffs(self, z: Float) -> list[Float]:
        """
        Perform a linearly interpolated lookup into the texture to fetch
        coefficients for a particular value of ``z``.
        """
        # Scale ``z`` according to the texture discretization
        # that places samples at position .5 within each texel
        n = self.nsamples
        z_scaled = dr.fma(z, dr.rcp(self.zmax) * (n - 1) / n, 0.5 / n)
        return self.coeff_tex.eval(Point1f(z_scaled))
    
    def eval(self, r: Float, radius: Float, σ : Float) -> Float:
        pdf, _, norm = self.eval_pdf(r, radius, σ)
        return pdf * norm
    

    def eval_pdf(self, r: Float, radius: Float, σ : Float) -> tuple[Float, Float, Float]:
        """
        Evaluate the Green's function CDF for position ``y`` (between 0 and 1)
        and parameter ``z``. The function returns a tuple containing

        - the CDF (normalized), which is normalized, i.e., ``eval(1, z)[0] == 1``
        - the y-derivative of the normalized CDF
        - the normalization constant

        It's fine to call this function even if you do not need all of the
        results. Dr.Jit will optimize the rest away.
        """
        #pdf, cdf, norm =  self.eval_pdf_with_coeffs_y(r/radius, self.fetch_coeffs(radius * dr.sqrt(σ)))
        pdf, cdf, norm =  self.eval_pdf_with_coeffs_y(r/radius, self.coeffs)
        pdf *= dr.rcp(radius)
        norm *= radius if self.is_grad else dr.square(radius)
        return pdf, cdf, norm


    def eval_pdf_with_coeffs_y(
        self, y: Float, coeffs: list[Float]
    ) -> tuple[Float, Float, Float]:
        """
        Implementation of the ``eval`` function. This function has
        essentially the same signature but expects that polynomial
        coefficients (obtained via ``fetch_coeffs()``) are provided
        via the ``coeffs`` parameter.
        """
        assert len(coeffs) == self.ncoeffs

        L_accum, Ld_accum, R_accum, Rd_accum, norm = (
            Float(0),
            Float(0),
            Float(0),
            Float(0),
            Float(0),
        )

        y2 = dr.square(y)

        for i in reversed(range(0, self.ncoeffs, 2)):
            exponent = i + 2 - int(self.is_grad)
            R, L = coeffs[i], coeffs[i + 1]
            R_accum = dr.fma(R_accum, y2, R)
            L_accum = dr.fma(L_accum, y2, L)
            Rd_accum = dr.fma(Rd_accum, y2, R * exponent)
            Ld_accum = dr.fma(Ld_accum, y2, L * exponent)
            norm += R

        log_x = dr.log(dr.maximum(y, 1e-10))
        inv_norm = dr.rcp(norm)

        value = dr.fma(L_accum, log_x, R_accum) * inv_norm
        deriv = dr.fma(Ld_accum, log_x, Rd_accum + L_accum) * inv_norm

        if self.is_grad:
            value *= y
        else:
            value *= y2
            deriv *= y

        return deriv, value, norm

    def eval_norm(self, radius : Float, σ : Float) -> Float:
        norm = Float(0)
        #coeffs = self.fetch_coeffs(radius * dr.sqrt(σ))
        for i in reversed(range(0, self.ncoeffs, 2)):
            norm += self.coeffs[i]
        norm *= radius if self.is_grad else dr.square(radius)
        return norm


    @dr.syntax # type: ignore
    def sample(self, x: Float, radius : Float, σ: Float) -> tuple[Float, Float]:
        # The expression to initialize the Newton iteration is numerically
        # unstable when 'z' is too small. Clamp to 1e-1 (for this part only)
        z = radius * dr.sqrt(σ)
        z_init = dr.maximum(z, 1e-1)
        b = None
        norm = Float(0)
        if dr.hint(not self.is_grad, mode='scalar'):
            if dr.hint(self.ndim == 2, mode='scalar'):
                # Based on 'Sample3Composed2' from the Mathematica notebook
                sqrt_x = dr.sqrt(x)
                b = 1 - dr.acosh(dr.fma(dr.cosh(z_init), 1 - sqrt_x, sqrt_x)) / z_init
            elif self.ndim == 3:
                # Based on 'Sample2Composed1' from the Mathematica notebook
                b = (1 - dr.acosh(dr.fma(dr.cosh(z_init), 1 - x, x)) / z_init) ** (2 / 3)
            else:
                raise RuntimeError("Unsupported number of dimensions!")
        else:
            # No good sampling strategy yet
            b = Float(x)

        # Fetch the coefficients once and then reuse them
        coeffs = self.coeffs

        # Bracketing interval
        a, c = Float(0), Float(1)

        # Iteration counter
        i = UInt32(0)

        while i < self.newton_steps:
            # Perform a Newton step
            deriv, cdf, norm = self.eval_pdf_with_coeffs_y(b, coeffs)
            b = b - (cdf - x) / deriv

            # Newton-Bisection: potentially reject the Newton step
            bad_step = ~((b >= a) & (b <= c))
            b = dr.select(bad_step, (a + c) / 2, b)

            # Update bracketing interval
            is_neg = self.eval_pdf_with_coeffs_y(b, coeffs)[1] - x < 0
            a = dr.select(is_neg, b, a)
            c = dr.select(is_neg, c, b)

            i += 1
        norm *= radius if self.is_grad else dr.square(radius)
        return b * radius, norm
    
    def eval_poisson_kernel(self, r: Float, radius: Float, σ : Float) -> Float:
        _, cdf, norm = self.eval_pdf(r, radius, σ)
        return 1 - cdf * norm * σ

